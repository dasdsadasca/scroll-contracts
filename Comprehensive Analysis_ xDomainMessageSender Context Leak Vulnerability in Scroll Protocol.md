# Comprehensive Analysis: xDomainMessageSender Context Leak Vulnerability in Scroll Protocol

## 1. Vulnerability Overview

The Scroll protocol contains a critical vulnerability in the `L1ScrollMessenger` contract where the `xDomainMessageSender` context can be leaked during cross-domain message execution. This context leak allows an attacker to bypass authorization checks in multiple contracts, potentially leading to unauthorized fund transfers, privilege escalation, and protocol state manipulation.

## 2. Technical Details of the Vulnerability

### 2.1 Core Vulnerability in L1ScrollMessenger.sol

The vulnerability exists in the `relayMessageWithProof` function in `L1ScrollMessenger.sol`:

```solidity
// File: /home/ubuntu/scroll-contracts/src/L1/L1ScrollMessenger.sol (Lines 175-208)
function relayMessageWithProof(
    address _from,
    address _to,
    uint256 _value,
    uint256 _nonce,
    bytes memory _message,
    L2MessageProof memory _proof
) external override whenNotPaused notInExecution {
    // Verification logic omitted for brevity...
    
    // @note check more `_to` address to avoid attack in the future when we add more gateways.
    if (_to == messageQueueV1 || _to == messageQueueV2 || _to == enforcedTxGateway) {
        revert ErrorForbidToCallMessageQueue();
    }
    _validateTargetAddress(_to);

    // @note This usually will never happen, just in case.
    require(_from != xDomainMessageSender, "Invalid message sender");

    xDomainMessageSender = _from;
    // xDomainMessageSender serves as reentrancy guard (notInExecution modifier).
    // slither-disable-next-line reentrancy-eth
    (bool success, ) = _to.call{value: _value}(_message);
    // reset value to refund gas.
    xDomainMessageSender = ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER;
    
    // Result handling omitted for brevity...
}
```

The key issue is that `xDomainMessageSender` is set to `_from` before the external call and only reset after the call completes. During the execution of the external call, the called contract has access to this context and can exploit it.

### 2.2 The notInExecution Modifier

The `notInExecution` modifier in `ScrollMessengerBase.sol` is intended to prevent reentrancy:

```solidity
// File: /home/ubuntu/scroll-contracts/src/libraries/ScrollMessengerBase.sol (Lines 48-55)
modifier notInExecution() {
    require(
        xDomainMessageSender == ScrollConstants.DEFAULT_XDOMAIN_MESSAGE_SENDER,
        "Message is already in execution"
    );
    _;
}
```

However, this only prevents nested calls to functions with this modifier, not calls to other functions during execution.

### 2.3 Default xDomainMessageSender Value

The default value for `xDomainMessageSender` is defined in `ScrollConstants.sol`:

```solidity
// File: /home/ubuntu/scroll-contracts/src/libraries/constants/ScrollConstants.sol (Lines 6-7)
/// @notice The address of default cross chain message sender.
address internal constant DEFAULT_XDOMAIN_MESSAGE_SENDER = address(1);
```

## 3. Authorization Checks Using xDomainMessageSender

Multiple contracts in the Scroll protocol use `xDomainMessageSender` for authorization:

### 3.1 ScrollGatewayBase.sol

```solidity
// File: /home/ubuntu/scroll-contracts/src/libraries/gateway/ScrollGatewayBase.sol (Lines 48-60)
modifier onlyCallByCounterpart() {
    // check caller is messenger
    if (_msgSender() != messenger) {
        revert ErrorCallerIsNotMessenger();
    }

    // check cross domain caller is counterpart gateway
    if (counterpart != IScrollMessenger(messenger).xDomainMessageSender()) {
        revert ErrorCallerIsNotCounterpartGateway();
    }
    _;
}
```

This modifier is used in gateway contracts to ensure that only the counterpart gateway on the other chain can call certain functions.

### 3.2 L2BatchBridgeGateway.sol

```solidity
// File: /home/ubuntu/scroll-contracts/src/batch-bridge/L2BatchBridgeGateway.sol (Lines 142-156)
function finalizeBatchDeposit(
    address l1Token,
    address l2Token,
    uint256 batchIndex,
    bytes32 hash
) external onlyMessenger {
    if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {
        revert ErrorMessageSenderNotCounterpart();
    }
    
    // Token mapping and state updates...
}
```

This function checks that the cross-domain message sender is the expected counterpart contract.

## 4. Exploitation Scenarios

### 4.1 Gateway Authorization Bypass

#### Scenario Details:

1. Attacker deploys `MaliciousL2Contract` on L2
2. Attacker deploys `MaliciousL1Contract` on L1
3. `MaliciousL2Contract` sends a message to L1 targeting `MaliciousL1Contract`
4. When `relayMessageWithProof` executes, `xDomainMessageSender` is set to `MaliciousL2Contract`
5. `MaliciousL1Contract` calls a function on a gateway contract that checks `xDomainMessageSender`
6. If `MaliciousL2Contract` has the same address as the expected counterpart, the check passes
7. The gateway executes privileged operations, such as token transfers

#### Example Exploit Code:

```solidity
// MaliciousL2Contract.sol
contract MaliciousL2Contract {
    IL2ScrollMessenger public messenger;
    
    constructor(address _messenger) {
        messenger = IL2ScrollMessenger(_messenger);
    }
    
    function sendAttackMessage(address maliciousL1Contract) external {
        bytes memory message = abi.encodeWithSignature("execute()");
        messenger.sendMessage(maliciousL1Contract, 0, message, 1000000);
    }
}

// MaliciousL1Contract.sol
contract MaliciousL1Contract {
    IL1ERC20Gateway public gateway;
    
    constructor(address _gateway) {
        gateway = IL1ERC20Gateway(_gateway);
    }
    
    function execute() external {
        // During this call, xDomainMessageSender is set to MaliciousL2Contract
        
        // Call finalizeWithdrawERC20 on the gateway
        gateway.finalizeWithdrawERC20(
            address(0x123), // L1Token
            address(0x456), // L2Token
            address(0x789), // from
            address(this),  // to (receive the tokens)
            1000000,        // amount
            new bytes(0)    // data
        );
    }
}
```

### 4.2 Token Bridge Exploitation

#### Scenario Details:

1. Attacker deploys contracts as in Scenario 4.1
2. `MaliciousL1Contract` calls `finalizeWithdrawERC20` on `L1ERC20Gateway`
3. The `onlyCallByCounterpart` check passes if `MaliciousL2Contract` has the same address as the counterpart
4. The gateway transfers tokens to the attacker's contract

#### Vulnerable Code in L1ERC20Gateway:

```solidity
// File: /home/ubuntu/scroll-contracts/src/L1/gateways/L1ERC20Gateway.sol (Lines 59-75)
function finalizeWithdrawERC20(
    address _l1Token,
    address _l2Token,
    address _from,
    address _to,
    uint256 _amount,
    bytes calldata _data
) external payable virtual override onlyCallByCounterpart nonReentrant {
    _beforeFinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);

    // @note can possible trigger reentrant call to this contract or messenger,
    // but it seems not a big problem.
    IERC20Upgradeable(_l1Token).safeTransfer(_to, _amount);

    _doCallback(_to, _data);

    emit FinalizeWithdrawERC20(_l1Token, _l2Token, _from, _to, _amount, _data);
}
```

### 4.3 Protocol State Manipulation

#### Scenario Details:

1. Attacker deploys contracts as in previous scenarios
2. `MaliciousL1Contract` calls `finalizeBatchDeposit` on `L2BatchBridgeGateway`
3. The check for `counterpart` passes if `MaliciousL2Contract` has the same address
4. The attacker can register malicious token mappings or manipulate batch hashes

#### Vulnerable Code in L2BatchBridgeGateway:

```solidity
// File: /home/ubuntu/scroll-contracts/src/batch-bridge/L2BatchBridgeGateway.sol (Lines 142-156)
function finalizeBatchDeposit(
    address l1Token,
    address l2Token,
    uint256 batchIndex,
    bytes32 hash
) external onlyMessenger {
    if (counterpart != IL2ScrollMessenger(messenger).xDomainMessageSender()) {
        revert ErrorMessageSenderNotCounterpart();
    }

    // trust the messenger and update `tokenMapping` in first call
    address storedL1Token = tokenMapping[l2Token];
    if (storedL1Token == address(0) && l1Token != address(0)) {
        tokenMapping[l2Token] = l1Token;
    } else if (storedL1Token != l1Token) {
        // this usually won't happen, check just in case.
        revert ErrorL1TokenMismatched();
    }

    batchHashes[l2Token][batchIndex] = hash;

    emit FinalizeBatchDeposit(l1Token, l2Token, batchIndex);
}
```

### 4.4 Delegatecall Exploitation

#### Scenario Details:

1. Attacker deploys contracts as in previous scenarios
2. `MaliciousL1Contract` uses delegatecall to call a legitimate contract
3. The legitimate contract checks `xDomainMessageSender` for authorization
4. The check passes because the storage context is preserved during delegatecall
5. The legitimate contract executes privileged operations with the attacker's logic

#### Example Exploit Code:

```solidity
// MaliciousL1Contract.sol with delegatecall
contract MaliciousL1Contract {
    address public legitimateContract;
    
    constructor(address _legitimateContract) {
        legitimateContract = _legitimateContract;
    }
    
    function execute() external {
        // During this call, xDomainMessageSender is set to MaliciousL2Contract
        
        // Delegatecall to legitimate contract
        (bool success, ) = legitimateContract.delegatecall(
            abi.encodeWithSignature("someFunction(address,uint256)", address(this), 1000000)
        );
        require(success, "Delegatecall failed");
    }
}
```

## 5. Address Aliasing Considerations

The Scroll protocol uses address aliasing to prevent address collisions between L1 and L2:

```solidity
// File: /home/ubuntu/scroll-contracts/src/libraries/common/AddressAliasHelper.sol (Lines 6-24)
/// @dev The offset added to the address in L1.
uint160 internal constant OFFSET = uint160(0x1111000000000000000000000000000000001111);

/// @notice Utility function that converts the address in the L1 that submitted a tx to
/// the inbox to the msg.sender viewed in the L2
/// @param l1Address the address in the L1 that triggered the tx to L2
/// @return l2Address L2 address as viewed in msg.sender
function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {
    unchecked {
        l2Address = address(uint160(l1Address) + OFFSET);
    }
}

/// @notice Utility function that converts the msg.sender viewed in the L2 to the
/// address in the L1 that submitted a tx to the inbox
/// @param l2Address L2 address as viewed in msg.sender
/// @return l1Address the address in the L1 that triggered the tx to L2
function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {
    unchecked {
        l1Address = address(uint160(l2Address) - OFFSET);
    }
}
```

This means that to successfully exploit the vulnerability, the attacker needs to ensure that their L2 contract's address, when aliased, matches the expected counterpart address.

## 6. Key Exploitation Questions

### 6.1 Address Matching Questions

1. **Q: Can an attacker deploy a contract on L2 with a specific address to match the expected counterpart address?**
   - This would require precise address calculation and potentially the use of CREATE2 to deploy contracts at predetermined addresses.
   - The attacker would need to calculate the address such that when aliased (with OFFSET added), it matches the expected counterpart.

2. **Q: Is it possible to use a proxy contract to achieve the address matching?**
   - Could a proxy contract on L2 forward calls to another contract while preserving the address that will be used in xDomainMessageSender?

### 6.2 Message Flow Questions

3. **Q: Can an attacker send a message from L2 to L1 that targets an arbitrary contract?**
   - Is there any restriction on what contracts can be targeted by L2->L1 messages?
   - Are there any additional checks beyond those in relayMessageWithProof?

4. **Q: How is the proof for relayMessageWithProof generated and verified?**
   - Can an attacker generate a valid proof for a malicious message?
   - Are there any centralized components that could prevent malicious proofs?

### 6.3 Timing and Synchronization Questions

5. **Q: Is there a time delay between sending a message from L2 and it being relayable on L1?**
   - Could this delay be used to prepare other aspects of an attack?
   - Are there any timeouts or expiration mechanisms for messages?

6. **Q: Who can call relayMessageWithProof?**
   - Is it permissionless or restricted?
   - If restricted, does this limit the exploitability?

### 6.4 Contract Interaction Questions

7. **Q: Can the attacker chain multiple contract calls during the execution context?**
   - Could they call multiple vulnerable contracts in sequence?
   - Is there a limit to the complexity of operations that can be performed?

8. **Q: Are there any contracts that use xDomainMessageSender for authorization but don't check the specific counterpart address?**
   - This would make exploitation easier as it wouldn't require address matching.

### 6.5 Delegatecall Questions

9. **Q: Which contracts in the protocol use delegatecall and also check xDomainMessageSender?**
   - These would be prime targets for exploitation.

10. **Q: Can a contract called via relayMessageWithProof use delegatecall to access another contract's logic while preserving the xDomainMessageSender context?**
    - This could allow for more complex exploitation scenarios.

### 6.6 Mitigation Questions

11. **Q: Would adding more addresses to the blocklist in relayMessageWithProof be sufficient to mitigate this vulnerability?**
    - Or is a more fundamental redesign of the context management needed?

12. **Q: Could a transaction-level guard that prevents any calls to sendMessage during the same transaction as relayMessageWithProof effectively mitigate this vulnerability?**
    - How would this impact legitimate protocol operations?

## 7. Potential Impact Assessment

### 7.1 Financial Impact

The vulnerability could lead to:

1. **Unauthorized Token Withdrawals**: By bypassing the `onlyCallByCounterpart` check in gateway contracts, an attacker could trigger unauthorized token transfers.

2. **Token Bridge Manipulation**: By manipulating token mappings in batch bridge contracts, an attacker could create invalid mappings that later facilitate theft.

3. **Fee Theft**: Some contracts may rely on `xDomainMessageSender` for fee distribution or collection logic.

### 7.2 Protocol Integrity Impact

The vulnerability threatens:

1. **State Corruption**: Unauthorized updates to protocol state like token mappings and batch hashes.

2. **Trust Assumptions Violation**: The protocol assumes messages from specific counterparts are trustworthy.

3. **Cross-Domain Security Model Breakdown**: The fundamental security model of the cross-domain messaging system is compromised.

## 8. Conclusion

The `xDomainMessageSender` context leak in the Scroll protocol is a critical vulnerability that affects multiple contracts and could lead to significant financial loss and protocol integrity issues. The vulnerability stems from a fundamental design flaw in how cross-domain message execution context is managed, and it requires a comprehensive solution rather than just expanding the blocklist.

Proper context isolation, transaction-level guards, or explicit sender validation would be necessary to fully address this vulnerability. Until such mitigations are implemented, the protocol remains at risk of sophisticated attacks that leverage this context leak to bypass critical authorization checks.
